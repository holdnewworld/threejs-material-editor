THREE.OBJExporter=function(){},THREE.OBJExporter.prototype={constructor:THREE.OBJExporter,parse:function(object){var i,j,k,l,m,output="",indexVertex=0,indexVertexUvs=0,indexNormals=0,vertex=new THREE.Vector3,normal=new THREE.Vector3,uv=new THREE.Vector2,face=[];return object.traverse(function(child){child instanceof THREE.Mesh&&function(mesh){var nbVertex=0,nbNormals=0,nbVertexUvs=0,geometry=mesh.geometry,normalMatrixWorld=new THREE.Matrix3;if(geometry instanceof THREE.Geometry&&(geometry=(new THREE.BufferGeometry).setFromObject(mesh)),geometry instanceof THREE.BufferGeometry){var vertices=geometry.getAttribute("position"),normals=geometry.getAttribute("normal"),uvs=geometry.getAttribute("uv"),indices=geometry.getIndex();if(output+="o "+mesh.name+"\n",mesh.material&&mesh.material.name&&(output+="usemtl "+mesh.material.name+"\n"),void 0!==vertices)for(i=0,l=vertices.count;i<l;i++,nbVertex++)vertex.x=vertices.getX(i),vertex.y=vertices.getY(i),vertex.z=vertices.getZ(i),vertex.applyMatrix4(mesh.matrixWorld),output+="v "+vertex.x+" "+vertex.y+" "+vertex.z+"\n";if(void 0!==uvs)for(i=0,l=uvs.count;i<l;i++,nbVertexUvs++)uv.x=uvs.getX(i),uv.y=uvs.getY(i),output+="vt "+uv.x+" "+uv.y+"\n";if(void 0!==normals)for(normalMatrixWorld.getNormalMatrix(mesh.matrixWorld),i=0,l=normals.count;i<l;i++,nbNormals++)normal.x=normals.getX(i),normal.y=normals.getY(i),normal.z=normals.getZ(i),normal.applyMatrix3(normalMatrixWorld).normalize(),output+="vn "+normal.x+" "+normal.y+" "+normal.z+"\n";if(null!==indices)for(i=0,l=indices.count;i<l;i+=3){for(m=0;m<3;m++)j=indices.getX(i+m)+1,face[m]=indexVertex+j+(normals||uvs?"/"+(uvs?indexVertexUvs+j:"")+(normals?"/"+(indexNormals+j):""):"");output+="f "+face.join(" ")+"\n"}else for(i=0,l=vertices.count;i<l;i+=3){for(m=0;m<3;m++)j=i+m+1,face[m]=indexVertex+j+(normals||uvs?"/"+(uvs?indexVertexUvs+j:"")+(normals?"/"+(indexNormals+j):""):"");output+="f "+face.join(" ")+"\n"}}else console.warn("THREE.OBJExporter.parseMesh(): geometry type unsupported",geometry);indexVertex+=nbVertex,indexVertexUvs+=nbVertexUvs,indexNormals+=nbNormals}(child),child instanceof THREE.Line&&function(line){var nbVertex=0,geometry=line.geometry,type=line.type;if(geometry instanceof THREE.Geometry&&(geometry=(new THREE.BufferGeometry).setFromObject(line)),geometry instanceof THREE.BufferGeometry){var vertices=geometry.getAttribute("position");if(output+="o "+line.name+"\n",void 0!==vertices)for(i=0,l=vertices.count;i<l;i++,nbVertex++)vertex.x=vertices.getX(i),vertex.y=vertices.getY(i),vertex.z=vertices.getZ(i),vertex.applyMatrix4(line.matrixWorld),output+="v "+vertex.x+" "+vertex.y+" "+vertex.z+"\n";if("Line"===type){for(output+="l ",j=1,l=vertices.count;j<=l;j++)output+=indexVertex+j+" ";output+="\n"}if("LineSegments"===type)for(k=(j=1)+1,l=vertices.count;j<l;k=(j+=2)+1)output+="l "+(indexVertex+j)+" "+(indexVertex+k)+"\n"}else console.warn("THREE.OBJExporter.parseLine(): geometry type unsupported",geometry);indexVertex+=nbVertex}(child)}),output}};